    Reflection — Lesson 2: DOM Manipulation(3 Oct 2025)
    ไฟล์: ui.js
    หัวข้อ: เชื่อม logic (quote.js) กับ UI (index.html) และจัดการ DOM

    [0] สรุปภาพรวม (What I built)
    - สร้าง “ท่อข้อมูล” (data flow) ระหว่าง logic และ UI:
    - ใช้ addNewQuote() เป็น wrapper เรียก addQuote() (จาก quote.js)
    - เรียก getAllQuotes() เพื่อดึงสถานะ (state) ของ quotes
    - ใช้ renderQuotes() เพื่อ “ล้าง” และ “วาด” DOM ใหม่ทุกครั้ง (idempotent render)
    - โค้ดรันด้วย ES Modules (import/export) และ <script type="module"> ใน index.html

    [1] แยกขอบเขตความรับผิดชอบ (Separation of Concerns)
    - quote.js = แหล่งความจริงของข้อมูล (source of truth): เก็บ/เพิ่ม/คืนค่ารายการคำคม
    - ui.js = ตัวเชื่อมต่อ UI: ดึงข้อมูล → แปลงเป็น DOM element → แสดงผล
    - ข้อดี: ทำให้ test และดูแลรักษาง่ายขึ้น (UI เปลี่ยนได้โดยไม่ต้องแก้ logic)

    [2] การออกแบบฟังก์ชัน (API design ในไฟล์นี้)
    - addNewQuote(content, author) → เป็น “thin wrapper” ที่คุมการเพิ่ม quote ให้ชัดเจน
    - ถ้าภายหลังต้องตรวจสอบ/validate (เช่น trim ช่องว่าง, ห้ามว่าง) จะใส่ไว้ที่นี่ได้เลย
    - renderQuotes() → ทำหน้าที่เดียว (Single Responsibility):
    - เคลียร์ container (innerHTML = '') เพื่อกันซ้อน/ซ้ำ
    - วนลูป quotes แล้วสร้าง <p> ต่อรายการ ด้วยรูปแบบ: "content" — author
    - ใช้ textContent เพื่อความปลอดภัย (ป้องกัน XSS) ไม่ใช้ innerHTML ต่อ string ตรง ๆ

    [3] เสถียรภาพการเรนเดอร์ (Rendering & Idempotency)
    - ทุกครั้งที่ renderQuotes() ทำงาน ผลลัพธ์จบที่ DOM “สอดคล้องกับ state ปัจจุบัน”
    - การ “ล้างก่อน-เติมใหม่” ช่วยเลี่ยงบั๊กสะสม (เช่น append ซ้ำ) และทำให้เหตุผลเชิงฟังก์ชันชัดเจน
    - เวลา-ความซับซ้อน O(n) ต่อจำนวน quotes (เพียงพอมากสำหรับแอปขนาดเล็ก)

    [4] DOM APIs ที่ได้ฝึกและเหตุผลที่ใช้
    - document.getElementById('quote-list') → ตรงและเร็ว เหมาะกับ id เดียว
    - document.createElement('p') + textContent → ปลอดภัยกว่า innerHTML (กัน script แปลกปลอม)
    - container.innerHTML = '' → เคลียร์เร็ว และอ่านง่าย (ทางเลือก: loop removeChild หรือ replaceChildren())

    [5] ES Modules & ลำดับการโหลดสคริปต์
    - ใช้ import { addQuote, getAllQuotes } from './quote.js'
    - <script type="module"> ทำให้เบราว์เซอร์โหลดแบบ defer โดยอัตโนมัติ
    - สคริปต์อยู่ท้าย <body> จึงมั่นใจว่า DOM (#quote-list) ถูก parse แล้วก่อนเรียก render
    - ผลคือ ไม่ต้องรอ DOMContentLoaded ก็ render ได้เลย (แต่ถ้าย้ายสคริปต์ขึ้น <head> อาจต้องรอ)

    [6] ความปลอดภัย (Security)
    - ใช้ textContent แทน innerHTML → ป้องกันการฉีดโค้ด (XSS) หากอนาคตเปิดให้ผู้ใช้กรอก quote
    - แยก logic/DOM ชัดเจน → ลดโอกาสโค้ดปะปนที่ควบคุมยาก

    [7] ประสิทธิภาพ (Performance)
    - ขนาดข้อมูลเล็ก: สร้าง <p> ตรง ๆ เข้า container พอเหมาะ
    - ถ้าข้อมูลใหญ่ขึ้น: อาจใช้ DocumentFragment เพื่อลด reflow/repaint หลายครั้ง
    (เช่น สร้าง fragment, append p หลายอันลง fragment, แล้วค่อย append ทีเดียว)
    - การเคลียร์ด้วย innerHTML = '' เร็วและตรงไปตรงมาในเคสนี้

    [8] การเข้าถึง (Accessibility, A11y) และ Semantic HTML
    - ตอนนี้ใช้ <p> ต่อ quote → อ่านง่าย
    - ถ้าต้องเน้น “รายการ” จริง ๆ อาจใช้ <ul><li> เพื่อ semantic ที่ชัดเจนกว่า
    - เพิ่ม aria-label ใน container หรือ heading ที่บอกว่าเป็น “Quote list” อาจช่วย reader

    [9] การตรวจสอบความถูกต้องของข้อมูล (Validation) — สิ่งที่เรียนรู้/ทำได้ต่อ
    - ใน addNewQuote() สามารถ:
    - trim content/author, กันค่าว่าง
    - ตัดช่องว่างซ้ำ, บังคับรูปแบบ (ตัวอักษร/ความยาว)
    - ป้องกันรายการซ้ำ (duplicate) ด้วยการเช็ค (content, author) ซ้ำหรือไม่

    [10] แนวคิด State & ความบริสุทธิ์ของฟังก์ชัน (Purity)
    - addQuote() มี side effect (แก้ state ภายใน quote.js)
    - renderQuotes() มี side effect กับ DOM (ซึ่งเป็น state ภายนอก)
    - ตระหนักรู้ว่า “pure vs impure” สำคัญต่อการ test:
    - ฟังก์ชัน pure → ทดสอบง่าย (input → output)
    - ฟังก์ชันที่มี side effect → ต้อง mock DOM/ state

    [11] การทดสอบ & ดีบัก (Testing & Debugging)
    - Unit test (เชิงแนวคิด):
    - เมื่อเรียก addNewQuote() 3 ครั้ง → getAllQuotes().length ควรเพิ่ม 3
    - renderQuotes() หลังเพิ่ม → จำนวน <p> ใน #quote-list เท่ากับจำนวน quotes
    - ค่าใน <p>.textContent ตรงตามฟอร์แมตที่กำหนด
    - Debug:
    - console.log(quotes) ก่อน render ช่วยตรวจว่าข้อมูลถูกต้อง
    - ตรวจ querySelector('#quote-list') ว่ามีจริง (การตั้ง guard ไว้แล้วช่วยกัน error)

    [12] สิ่งที่ “ตัดสินใจ” แล้ว และทางเลือก (Trade-offs)
    - “ล้างแล้ววาดใหม่” (clear & re-render) vs “diff & patch” เฉพาะส่วนที่เปลี่ยน
    - สำหรับบทเรียน/ข้อมูลน้อย → ล้างแล้ววาดใหม่ อ่านง่ายและพอเพียง
    - ถ้าขยายใหญ่ → พิจารณา diff เอง หรือใช้เฟรมเวิร์ก (React/Vue) ช่วยดูแล DOM
    - เลือก textContent แทน innerHTML:
    - ปลอดภัยกว่า, แต่ฟอร์แมต HTML ภายใน string ไม่ได้ (ถ้าต้องการ format จัด <span> เอง)

    [13] ความเข้าใจเชิงเวลา (Temporal reasoning)
    - การเรียก render หลัง addNewQuote() 3 ครั้ง → ควบคุม “ลำดับเหตุการณ์” ให้แน่นอน
    - ใช้ module script ที่อยู่ท้าย body → DOM พร้อมก่อน code ทำงาน (ลด race condition)

    [14] สิ่งที่ได้จากบทเรียนนี้ (Key Takeaways)
    - เชื่อมต่อโมดูล logic ↔ UI อย่างเป็นระบบ
    - ควบคุมการเรนเดอร์ DOM ให้สอดคล้องกับ state ล่าสุด (idempotent render)
    - ใช้ API DOM พื้นฐานได้คล่อง (query, create, append)
    - คิดเผื่อเรื่อง Security (XSS), Performance (reflow), A11y (semantic)
    - ออกแบบฟังก์ชันเล็ก-ชัดเจน (SRP) และวางทางขยายในอนาคตได้ง่าย

    [15] ไอเดียพัฒนาต่อ (Next Steps)
    - เพิ่มฟอร์ม “Add Quote” + ปุ่ม Add → ผูก event แล้วเรียก addNewQuote() → renderQuotes()
    - ปุ่ม Delete/Edit ต่อรายการ (event delegation ที่ container เดียว)
    - เก็บข้อมูลใน localStorage เพื่อคงสภาพหลังรีเฟรช
    - สลับมุมมองเป็น <ul><li> + role="list" เพื่อ semantic ที่ดี
    - ใช้ DocumentFragment เมื่อจำนวนรายการมากขึ้น
    - เขียน unit tests เบื้องต้น (เช่น ด้วย Jest + jsdom)

    [16] สิ่งที่ “จะทำต่างออกไป” ถ้าเริ่มใหม่
    - ตั้ง type/shape ของ Quote ชัดเจน (เช่น { id, content, author, createdAt })
    - แยกเลเยอร์ view เป็นฟังก์ชันเล็ก ๆ เช่น createQuoteElement(q) คืนค่า <p>/ <li>
    - เตรียม data sanitization ตั้งแต่ addNewQuote()